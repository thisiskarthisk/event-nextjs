import { DB_Fetch, DB_Insert, Tables } from "@/db";
import { JsonResponse } from "@/helper/api";
import bcrypt from "bcrypt";
import Validation from "@/helper/validation";
import { sql } from "drizzle-orm";

// ❗ Helper function to generate the next Employee ID based on the next sequential ID
async function generateNextEmployeeId(prefix, digits) {
    let nextUserId = 1;
    
    // 1. Find the current maximum 'id' from the users table (using TBL_USERS from Tables)
    try {
        const lastRecord = await DB_Fetch(sql`
            SELECT id FROM ${sql.identifier(Tables.TBL_USERS)} ORDER BY id DESC LIMIT 1
        `);
        
        // If a record is found, the next ID is max ID + 1. Otherwise, start at 1.
        nextUserId = lastRecord.length > 0 ? Number(lastRecord[0].id) + 1 : 1;
    } catch (lastErr) {
        console.error('Error fetching last user ID for sequence:', lastErr);
        // Fallback: If DB fetch fails, rely on the provided 'digits' padding 
        // starting from 1, but log the error.
    }

    // 2. Generate the final Employee ID
    const paddedId = String(nextUserId).padStart(Number(digits), '0');
    return `${prefix.trim()}${paddedId}`;
}


export async function POST(req) {
  try {
    const data = await req.json();
    const isUpdate = !!data.id;
    
    // --- 1. Check for Employee ID Auto-Generation Setting ---
    let isEmployeeIdAutoGenerated = false;
    let generatedEmployeeId = null;
    let employeeIdValueToInsert = data.employee_id; // Default to manual input value

      if (!isUpdate) { // Only check and generate for new inserts
        const settingResults = await DB_Fetch(sql`
            SELECT value FROM ${sql.identifier(Tables.TBL_SETTINGS)}
            WHERE setting_group = 'general' AND field_name = 'employee_id'
        `);

        const settingValue = settingResults?.[0]?.value;

        if (settingValue) {
            // Expected format: "PREFIX,DIGITS" (e.g., "EMP,4")
            const [prefix, digitsStr] = settingValue.split(',');
            const digits = parseInt(digitsStr, 10);

            if (prefix && !isNaN(digits) && digits > 0) {
                isEmployeeIdAutoGenerated = true;
                
                // ❗ Auto-generate the ID
                generatedEmployeeId = await generateNextEmployeeId(prefix.trim(), digits);
                employeeIdValueToInsert = generatedEmployeeId;
                
                console.log('Generated Employee ID:', generatedEmployeeId);
            }
        }
        // ❗ CRITICAL CHECK: If inserting, and the setting is missing/invalid, STOP and return error.
        if (!isEmployeeIdAutoGenerated && !data.employee_id) {
             return JsonResponse.error("Please First Employee ID Set in Setting Then Create Users.", 422);
        }
      }

    // --- 2. Define Validation Rules ---
    let rules = {
      first_name: "required",
      last_name: "required",
      email: "required|email",
      mobile_no: "required|mobile_no"
    };

    // ❗ Require employee_id only if it's NOT auto-generated AND it's a new insert, or if it's an update.
    if (!isEmployeeIdAutoGenerated || isUpdate) {
        rules.employee_id = "required|alpha_num";
    }

    if (!isUpdate) {
      rules.password = "required";
    }

    // --- 3. Validate Data ---
    // If auto-generated, we ensure the employee_id field is empty in the validation data 
    // since the frontend won't send it, but we already handled the requirement check above.
    const dataForValidation = isEmployeeIdAutoGenerated && !isUpdate 
        ? { ...data, employee_id: undefined } // Remove employee_id from data for validation if it's auto-generated
        : data;

    const errors = Validation(dataForValidation, rules);
    
    if (errors && Object.keys(errors).length > 0) {
      return JsonResponse.error("Please correct the errors.", 422, errors);
    }
    
    // ❗ Final safety check for insertion if manual ID was required but missing
    if (!isUpdate && !isEmployeeIdAutoGenerated && !employeeIdValueToInsert) {
         return JsonResponse.error("Employee ID is required for user creation.", 422);
    }


    const passwordHash = data.password ? await bcrypt.hash(data.password, 10) : null;

    // --- 4. Handle UPDATE ---
    if (isUpdate) {
      await DB_Fetch(sql`
        UPDATE ${sql.identifier(Tables.TBL_USERS)}
        SET
          employee_id = ${employeeIdValueToInsert},
          first_name  = ${data.first_name},
          last_name   = ${data.last_name},
          email       = ${data.email},
          mobile_no   = ${data.mobile_no},
          password    = COALESCE(${passwordHash}, password),
          updated_at  = NOW()
        WHERE id = ${Number(data.id)}
      `);

      return JsonResponse.success(
        { id: data.id },
        "The User has been updated successfully."
      );
    }

    // --- 5. Handle INSERT ---
    // ❗ Use the determined employeeIdValueToInsert
    const inserted = await DB_Insert(sql`
      INSERT INTO ${sql.identifier(Tables.TBL_USERS)}
        (employee_id, first_name, last_name, email, mobile_no, password)
      VALUES
        (${employeeIdValueToInsert}, ${data.first_name}, ${data.last_name}, ${data.email}, ${data.mobile_no}, ${passwordHash})
    `);

    return JsonResponse.success(
      { id: inserted },
      "The User has been created successfully."
    );
  } catch (error) {
    console.error("[api/users/save] Error:", error);

    let message = "Error occurred while saving user.";

    if (error.cause?.constraint) {
      if (error.cause.constraint.includes("unique_employee_id"))
        message = "Employee ID already taken.";
      else if (error.cause.constraint.includes("unique_email"))
        message = "Email already used.";
      else if (error.cause.constraint.includes("unique_mobile_no"))
        message = "Mobile number already used.";
    }

    return JsonResponse.error(message);
  }
}